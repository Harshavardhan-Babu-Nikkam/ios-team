# O.C. Tanner Swift Style Guide

This style guide outlines the coding conventions of the iOS team at O.C. Tanner. We welcome your feedback in [issues](https://github.com/octanner/ios-team/issues) and [pull requests](https://github.com/octanner/ios-team/pulls).

## Introduction

This guide is based on the following sources:

* [Swift API Design Guidelines](https://swift.org/documentation/api-design-guidelines/)
* [NYTimes Objective-C Style Guide](https://github.com/NYTimes/objective-c-style-guide)
* [Netguru's Swift Style Guide](https://github.com/netguru/swift-style-guide)
* [Sport Ngin Style Guide](http://sportngin.github.io/styleguide/swift.html)

## Table of Contents

* [Organization](#organization)
  * [init & deinit](#init-and-deinit)
  * [Remove Unused Code](#remove-unused-code)
* [Spacing](#spacing)
* [Imports](#imports)
* [Modifier Keyword Order](#modifier-keyword-order)
* [Naming](#naming)
  * [Image Naming](#image-naming)
* [Constants](#constants)
  * [Singletons](#singletons)
* [Enumerated Types](#enumerated-types)
* [Implicit Getters](#implicit-getters)
* [Private Properties](#private-properties)
* [Collection Syntactic Sugar](#collection-syntactic-sugar)
* [Typed Collection Initialization](#typed-collection-initialization)
* [Variables](#variables)
  * [Colon Placement](#colon-placement)
  * [Native Over Bridged](#native-over-bridged)
  * [Mutability](#mutability-let-over-var)
* [Optionals](#optionals)
  * [Implicitly Unwrapped Optionals](#implicitly-unwrapped-optionals)
* [Closures](#closures)
* [Conditionals](#conditionals)
  * [Ternary Operator](#ternary-operator)
  * [Nil Coalescing Operator](#nil-coalescing-operator)
* [Explicit References to Self](#explicit-references-to-self)
* [Static vs. Dynamic Code](#static-vs-dynamic-code)
* [Extensions](#extensions)
* [Error Handling](#error-handling)

## Organization

There should be one blank line between methods to aid in visual clarity and organization. There should be two blank lines between classes or extensions within the same file. End files with an empty line.

Use `// MARK: -` to categorize methods into functional groupings and protocol implementations. Place two blank lines above the mark unless it is the first statement in the body. Place one blank line after the mark. In smaller files (say less that 100ish LOC), the code should be easy enough to follow that `// MARK` is unecessary.

**For example:** (assuming the file is larger than 100 LOC)

```swift
public class DelayOperation: Operation {

    // MARK: - Types

    private enum Delay {
        case Interval(NSTimeInterval)
        case Date(NSDate)
    }


    // MARK: - Properties

    private let delay: Delay


    // MARK: - Initialization

    public init(interval: NSTimeInterval) {
        delay = .Interval(interval)
        super.init()
    }

    public init(until date: NSDate) {
        delay = .Date(date)
        super.init()
    }


    // MARK: Public methods

    override public execute() {
        /*  */
    }

    // ... more functions

}
```

Whitespace within methods should be used to separate functionality (though often this can indicate an opportunity to split the method into several, smaller methods). Use comments where appropriate, but realize that comments (like the aforementioned white space) can also indicate a further opportunity to decompose your method, or use more clear naming. Also, if your file gets large enough to merit several `// MARK`, this might be a yet another sign that you need to consider some decomposition, or that you are not following the [Single Responsibility Principle](https://en.wikipedia.org/wiki/Single_responsibility_principle).

### init and deinit

`deinit` methods should be placed at the top of the class body, directly after the property declarations. `init` should be placed directly below the `deinit` methods of any class.

### Remove Unused Code

Don't commit code that will never execute: just delete it. You probably won't ever want it back, and if you do, you'll likely want to rewrite it anyway. And you can always retrieve it from an earlier commit if you have to. This applies to:

* Methods that are never called
* Commented-out code
* Code protected by impossible if or switch statements

Don't commit code that serves no purpose. This applies to:

* Code automatically generated by Xcode that does nothing except call super
* Empty conditional bodies (`if foo { }` or `else { }`)

## Spacing

* Indent using 4 spaces. Never indent with tabs. Be sure to set this preference in Xcode.
* Method braces and other braces (`if`/`else`/`switch`/`while` etc.) always open on the same line as the statement but close on a new line, though `else` follows the previous closing brace.

**For example:**
```swift
if user.isHappy {
    // Do something
} else {
    // Do something else
}
```

## Imports

If there is more than one `import` statement, order the statements alphabetically. This allows for easy removal when you no longer need that module in your code.

**For example:**
```swift
import CoreData
import ModelModule
import QuartzCore
```

## Modifier Keyword Order

When you declare a type, method or property, follow a consistent ordering of any modifier keywords used. Use access modifiers only if necessary. Pay attention to variables. Use `private` or `private(set)` appropriately. Don't add modifiers if they are are already a default.

```swift
[ @objc | @NSManaged | other attribute modifiers ]
override
public
internal // only if necessary
private
[ static | class ]
[ required | optional ]
final
[ mutating | nonmutating ]
lazy
weak
[ class | enum | init | func | let | var, etc. ]
```

**For example:**
```swift
@NSManaged public private(set) var name: String?

override public class final func someMethod() {
    // Method body
}
```

## Naming

Apple naming conventions should be adhered to wherever possible. Long, descriptive method and variable names are good.

**For example:**

```swift
let settingsButton: UIButton
```

**Not**

```swift
let setBut: UIButton
```

Properties, `case` names, local variables, and `static` constants should be camel-case with the the first letter lowercase. When referencing the constant, it will usually require being prefixed by the related class name.

**For example:**

```swift
class ArticleViewController {
    static let navigationFadeAnimationDuration = 0.3
}
```

**Not:**

```swift
class ArticleViewController {
    static let fadetime = 1.7
}
```

### Image Naming

Image names should be chosen consistently to preserve organization and developer sanity. They should be named as one camel case string with a description of their purpose, followed by the un-prefixed name of the class or property they are customizing (if there is one), followed by a further description of color and/or placement, and finally their state.

**For example:**

* `RefreshBarButtonItem` / `RefreshBarButtonItem@2x` and `RefreshBarButtonItemSelected` / `RefreshBarButtonItemSelected@2x`
* `ArticleNavigationBarWhite` / `ArticleNavigationBarWhite@2x` and `ArticleNavigationBarBlackSelected` / `ArticleNavigationBarBlackSelected@2x`.

Images that are used for a similar purpose should be grouped in respective groups in an Images folder or Asset Catalog.

## Constants

Constants are preferred over in-line string literals or numbers, as they allow for easy reproduction of commonly used variables and can be quickly changed without the need for find and replace. Constants should be declared as `private static let` if used in multiple functions, otherewise a simple local `let` inside the function will suffice.

**For example:**

```swift
class User {

    private static let userKey = "user"
    private static let nameKey = "name"

}
```

**Not:**

```swift
private let userKey = "user"
private let nameKey = "name"

class User {

}
```

### Singletons & Shared Instances

Singleton objects and shared instances should use the simple thread-safe pattern for creating their shared instance. Use the name `sharedInstance` when instantiating a private instance is possible, but rare (similar to `NSURLSession.sharedSession()`). Use `defaultInstance` when it's common to instantiate a private instance, but convenient to have a default instance (similar to `NSURLSessionConfiguration.defaultSessionConfiguration()`).

```swift
class Thermometer {

    static let sharedInstance = Thermometer()

}
```

Additionally, true singleton classes should declare all initializers as `private`.

It is better to prefer shared instances over true singletons. This allows for dependency injection and more testability.

When a class uses a shared instance internally, always declare a property for it like this:

```swift
class MyViewController: UIViewController {
	var manager = SomeManager.sharedManager
}
```

Then, _always_ use the declared property, and never `SomeManager.sharedManager` directly. This allows you to replace `manager` with a mock.


## Enumerated Types

When using `enum`s, reserve using raw types for enums whose raw values are used in storage or other I/O. All other enums should be declared without a raw value.

**Example:**

```swift
enum TemperatureUnit: String {
    case kelvin = "K"
    case celsius = "C"
    case farenheit = "F"
}

enum FeedCellType {
    case storyCell
    case adCell
}
```

Where possible while using `String` based enums, prefer naming the case the same as the `rawValue`. This way no explicit definition of the raw value is neccessary.

```swift
enum Segue: String {
    case pushDetailViewController // no = "pushDetailViewController"
    case presentNewItemViewController
}
```

## Implicit getters

Read-only computed properties don't need an explicit getter, thus it can be omitted. This also applies to read-only subscripts.

```swift
struct Person {

    let height: Float
    let weight: Float

    var bmi: Float {
        return weight / (height * height)
    }

}
```

## Private Properties

Private properties should be used where possible, hiding how a class does its work and allowing it to change over time without impacting surrounding classes. All non-private properties should be considered part of a class's published API, and changes to those will likely cause a ripple of changes to other classes. Read-only `@NSManaged` properties should declare their setters to be private.

**For example:**

```swift
class PatientVitals {

    @NSManaged public private(set) var dateCreated: NSDate?

    @NSManaged private var temperatureCelsius: NSDecimalNumber?
    public var temperature: Temperature? {
      // Convert from decimal to struct
    }

}
```

## Collections

We use the syntactic sugar provided by Swift when working with `Array` and `Dictionary`.

```swift
let numbers: [Int]
let json: [String: AnyObject]
```

**Not:**:

```swift
let numbers: Array<Int>
let json: Dictionary<String, AnyObject>
```

If you find yourself having too many nested arrays or dictionaries, it's time for some `typealias`.

Collections should be initialized with literal values where possible. When building collection contents dynamically, initialize them with the type declaration on the right-hand side of the expression. Property declarations providing an initial value should follow these conventions.

**For example:**

```swift
let names = ["Brian", "Matt", "Chris", "Alex", "Steve", "Paul"]
let productManagers = ["iPhone": "Kate", "iPad": "Kamal", "Mobile Web": "Bill" ]
```

or:

```swift
var developers = [String]()
var developersByTeam = [String: String]()
```

**Not:**

```swift
var names = [String]()
names = ["Brian", "Matt", "Chris", "Alex", "Steve", "Paul"]
```

## Variables

Variables names should clearly communicate what the variable _is_ and pertinent information a programmer needs to use that value properly.

Use implicit typing. This creates a greater need for thoughtful variable names which lead to reasonable assumptions about their types.

**For example:**

* `title`: It is reasonable to assume a “title” is a string.
* `titleHTML`: This indicates a title that may contain HTML which needs parsing for display. _“HTML” is needed for a programmer to use this variable effectively._
* `titleAttributedString`: A title, already formatted for display. _`AttributedString` hints that this value is not just a vanilla title, and adding it could be a reasonable choice depending on context._
* `now`: _No further clarification is needed._
* `lastModifiedDate`: Simply `lastModified` can be ambiguous; depending on context, one could reasonably assume it is one of a few different types.
* `url` vs. `urlString`: In situations when a value can reasonably be represented by different classes, it is often useful to disambiguate in the variable’s name.
* `releaseDateString`: Another example where a value could be represented by another class, and the name can help disambiguate.

Single letter variable names should be avoided except as simple counter variables in loops.

### Colon Placement

Colons indicating an explicit type should be “attached to” the variable name.

**For example:**
```swift
let text: String
```

**not**
```swift
let text : String
```

**and not:**
```swift
let text :String
```

Colons used in dictionaries should follow a similar pattern, and be placed next to the keys of the dictionary.

**For example:**
```swift
let assignments = ["History": "Essay V", chemistry: "Experiment #3"]
```

**and**
```swift
class Homework {

    var completedAssignments = [String: String]

    func reset() {
        completedAssignments = [:]
    }

}
```

**not**
```swift
let assignments = ["History" : "Essay V", chemistry : "Experiment #3"]
```

**and not:**
```swift
let assignments = ["History":"Essay V", chemistry:"Experiment #3"]
```

### Native over bridged

Always use Swift's native types when available. Swift offers bridging to Objective-C so you can still use the full set of methods as needed.

**For example:**
```swift
let width = 120.0
let widthString = (width as NSNumber).stringValue
```

**not**
```swift
let width: NSNumber = 120.0
let widthString: NSString = width.stringValue
```

### Mutability: `let` over `var`

Use `var` only when necessary, e.g. when you're absolutely sure you will be changing the value in the future.

At all other times, and when in doubt, use `let`.

It's safer to assume that a variable is immutable, thus it's highly recommended to declare values as constants, using `let`. Immutable constants ensure their values will never change, which results in less error-prone code.

Whenever you see a `var` identifier being used, assume that it will change and ask yourself why.

## Optionals

Force unwrapping should be avoided as much as possible. Implicitly unwrapped optionals lead to less safe code and can cause unwanted crashes. Use optional chaining or `if-let` bindings to unwrap optional values.

```swift
let user: User? = findUserById(123)

if let user = user {
    println("found user \(user.name) with id \(user.id)")
}
```

Unwrapping several optionals in nested `if-let` statements is discouraged, as it leads to the "pyramid of doom". Swift allows you to unwrap multiple optionals in one statement.

```swift
let name: String?
let age: Int?

if let name = name, age = age where age >= 13 {
    /* ... */
}
```

For particularly long chains, consider putting each item on a new line:

```swift
if let name = name,
       age = age,
       email = email,
       address = address {
    /* ... */
}
```

In cases where you care about identifying the point of failure in the chain, use multiple `guard let` statements.

```swift
guard let name = name else { /** print, throw error, fatalError, etc. */ }
guard let age = age else { /** print, throw error, fatalError, etc. */ }
guard let email = email else { /** print, throw error, fatalError, etc. */ }
guard let address = address else { /** print, throw error, fatalError, etc. */ }
```

### Implicitly Unwrapped Optionals

Implicitly unwrapped optionals can sometimes be useful. They may be used in unit tests, where system under test should never be `nil` and there's no point executing the application if it is. Examples include `@IBOutlet`s or `NSManagedObjectContext`s set on view controllers before their use.

```swift
var context: NSManagedObjectContext!

override func viewDidLoad() {
    // Load the data for this view using the context
}
```

**However**, you must still exercise extreme caution when working with implicitly unwrapped optionals. Consider the following code:

```swift
class MyViewController: UIViewController {
    
    @IBOutlet var titleLabel: UILabel!
    
    var name: String? {
        didSet {
            titleLabel.text = name
        }
    }
    
}
```

If a caller sets `name` _before_ the view loads this code will crash.

In practice, make sure that any configuration code that can be called before the view loads treats the unwrapped optionals as optionals.

## Closures

Remove all unneeded elements when using closures, and use trailing closure syntax whenever possible.

**For example:**
```swift
dispatch_async(dispatch_get_main_queue()) {
    /*  */
}
```

**not**
```swift
dispatch_async(dispatch_get_main_queue(), { () -> Void in
    /*  */
})
```

However, when a method signature includes multiple closures, prefix each to keep it clear what each closure is for.

**For example:**
```swift
authenticate(userId, password: password, success: {
    /*  */
}, failure: { error in
    /*  */
})
```

**not**
```swift
authenticate(username, password: password, success: {
    /*  */
}) { error in
    /*  */
}
```

Because this is much more awkward than trailing closure syntax, create functions which are friendly to trailing closure syntax.

**For example:**
```swift
func authenticate(username: String, password: password, completion:(NSError) -> Void) {
  /*  */
}
```

**not**
```swift
func authenticate(username: String, password: password, success: () -> Void, failure:(NSError) -> Void) {
  /*  */
}
```

## Conditionals

Prefer `guard` statements written on a single line. Write `if` statements on multiple lines.

**For example:**
```swift
guard let user = currentUser else { return }
```

and
```swift
if !error {
    return success
}
```


**Not:**
```swift
guard let user = currentUser else {
    return
}
```

and not:

```swift
if !error { return success }
```

### Ternary Operator

The ternary operator, `?`, should only be used when it increases clarity or code neatness. A single condition is usually all that should be evaluated. Evaluating multiple conditions is usually more understandable as an if statement, or refactored into named variables.

**For example:**
```swift
result = a > b ? x : y
```

**Not:**
```swift
result = a > b ? x = c > d ? c : d : y
```

A good rule of thumb is if you are having to use parentheses to keep things "readable", a traditional `if-else` is probably more appropriate.

### Nil Coalescing Operator

Use the Nil Coalescing Operator, `??`, instead of using the ternary operator to check for `nil` and provide a default value when assigning values to non-optional variables.

**For example:**
```swift
let apple = optionalApple ?? redDelicious
```

**Not:**
```swift
let apple = optionalApple != nil ? optionalApple! : redDelicious
```

## Explicit references to `self`

Explicit references to `self` should only take place when the language requires it.

```swift
struct Person {

    let firstName: String
    let lastName: String

    var fullName: String {
        return "\(firstName) \(lastName)"
    }

    init(firstName: String, lastName: String) {
        self.firstName = firstName
        self.lastName = lastName
    }

}
```

## Static vs. dynamic code

Static code is code where logic and control can be resolved at compile-time. The Swift compiler is able to optimize predictable code to work better and faster. Try to make use of this feature and write as much static code as possible.

On the other hand, dynamic code's control flow is resolved at run-time, which means it's not predictable and, as a result, can't be optimized by the compiler. Avoid using `dynamic` and `@objc` attributes.

## Extensions

Whenever possible where you have an object that conforms to a protocol, put the corresponding members/methods in an extension that declares conformance.

```swift
extension MyViewController: UITableViewDelegate {
    // ... Delegate method implementations
}
```

When using a `private extension` for separating out `private` methods, be sure to still explicitly label each method as `private`; in long extensions it becomes difficult to infer the visibility modifier.

## Error Handling

Use Swift's native error handling for any synchronous error handling.

For async error handling, prefer passing back a `Result` object.

# Other Swift Style Guides

If ours doesn’t fit your tastes, have a look at some other style guides:

* [GitHub](https://github.com/github/swift-style-guide)
* [NetGuru](https://github.com/netguru/swift-style-guide)
* [Ray Wenderlich](https://github.com/raywenderlich/swift-style-guide)
* [Sport Ngin](http://sportngin.github.io/styleguide/swift.html)
